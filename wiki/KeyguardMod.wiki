#summary master process framework for skipping the keyguard and acquiring wakelocks so we can open our fancy homescreen with ease!

= Why have a keyguard without any keys of note? =

The useful thing of the keyguard is really in the regulation of it going back to sleep again faster when you haven't interacted with the device, giving you a slightly longer timeout if you have touched something and even longer if you have opened the slide. 

== What's going on under the hood ==
To re-do the keyguard, all we have to do is disable the original keyguard when it gets called, then call our activity up. Our latest code is based a WelcomeActivity, and the keyguard skip occurs in onCreate. It talks to the window manager to get a clean keyguard bypass that is automatically restored when device goes to sleep again. Our other method simply disables keyguard immediately upon receiving screen on, and calls re-enable immediately upon every screen off. That method seems to break the home long press & shortcut key functionality, it will start working only after launching home once. A workaround to this might be to have our app set as default home and automatically handle the launcher intent.

=  Power control concerns: when to re-sleep? =
myLock will take efficient control of how long the screen stays & how bright in the absence of user originated sleep commands. This is the gatekeeper to respect the user's intent for viewing or input on the device, it knows when to sleep or how bright to be and in what ways, depending on circumstances of what just happened.

in android 2.0 it kind of auto-dims before the autolock kicks in, if you are set at anything above lowest brightness. users will be able to make the autosleep vs autodim work for them and respect whether the keypad is open, and other factors.

==Some Code Stuff==

The current default keys that get suppressed from waking up the screen are defined in KeyguardViewMediator.java -- redefining these to allow more control over the backlight and further allow it to re-sleep faster when keyguard is being shown could be part of this addon. 
{{{
    private boolean isWakeKeyWhenKeyguardShowing(int keyCode) {
        switch (keyCode) {
            case KeyEvent.KEYCODE_VOLUME_UP:
            case KeyEvent.KEYCODE_VOLUME_DOWN:
            case KeyEvent.KEYCODE_MUTE:
            case KeyEvent.KEYCODE_HEADSETHOOK: 
            case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE: 
            case KeyEvent.KEYCODE_MEDIA_STOP: 
            case KeyEvent.KEYCODE_MEDIA_NEXT: 
            case KeyEvent.KEYCODE_MEDIA_PREVIOUS: 
            case KeyEvent.KEYCODE_MEDIA_REWIND: 
            case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
            case KeyEvent.KEYCODE_CAMERA:
                return false;
        }
        return true;
    }
}}}

We have learned that it simply isn't possible because of this code and the nature of key events to handle buttons while the device is asleep. Buttons can either cause wake, or not cause it, and we can completely kill guarding such that wake will always happen with any key, but we cannot get new logic in place that will let us offer custom key sequence unlocks such as long press, double press, or specific key exclusion. This might be possible in root. I will need to research further to find out.

We need to give permission in the manifest to disable the keyguard
{{{
<uses-permission
    android:name="android.permission.DISABLE_KEYGUARD" />
}}}

===Transition from simple KG skip to power controls & input monitoring===
Currently our code just responds to screen_on/off broadcasts and enables or disables keyguard. The new code needs to accomplish a few specifics

Persistence: Remote service handles the screen off and on occurrences. Here are the references I followed to get the service changed to a foreground start so we can ensure persistence that is rock solid. http://developer.android.com/reference/android/app/Service.html 
http://developer.android.com/guide/topics/ui/notifiers/notifications.html

Modular Functions for wakeup screens: Functions/methods which call the different types of wakeup/unlock. This is so that they are independent of the circumstance they will be invoked under, allowing our customization to work easily. User pref of whether to use the custom home or the regular home and only call up shortcutter when needed.
Types of wakeup/unlock:
  * Quick unlock (alpha 1 method)
  * Wakeup welcome screen (alpha 2 method), auto-dismiss
  * Wakeup welcome home screen (upcoming - a lockscreen that houses widgets)

Idle Re-Sleep Regulation: Implement the first basics of re-sleep regulation. I don't know if we will need to place very much for this initially but the framework should be considered to allow our planned customizations in future builds